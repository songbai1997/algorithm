# 模板
dp[i][j] 表示以 i 为起点，长度为 2 ^ j 的区间内的最值
dp[i][j] = max(dp[i][j - 1], dp[i + (1 << (j - 1))][j - 1])
```cpp
const int N = 10001;
int a[N], dp[N][21];

void st(int n) {
    // 数组下标从 1 开始
    for (int i = 1; i <= n; i++) dp[i][0] = a[i]; // i 开始的长度为 1 的元素中最大值是 a[i]
    for (int j = 1; (1 << j) <= n; j++) // 枚举长度
        for (int i = 1; i + (1 << j) - 1 <= n; i++) // 枚举起点
            dp[i][j] = max(dp[i][j - 1], dp[i + (1 << (j - 1))][j - 1]);

    // code 关键点 1 ： 枚举长度时，边界条件是 (1 << j) <= n，这是为了保证，
    // 当数组长度是 2 的 k 次方时，dp[1][k] 能获得更新
    
    // code 关键点 2 ： 枚举起点时，边界条件是 i + (1 << j) - 1 <= n, dp[i][j] 
    // 管理的区间为 [i, i + (1 << j) - 1], 只要右端点
    // i + (1 << j) - 1 在 [1, n] 的范围内就合法
}

// 查询数组 a 的 [l, r] 区间的
int query(int l, int r) {
    int k = (int)(log((double)(r - l + 1)) / log(2.0));
    return max(dp[l][k], dp[r - (1 << k) + 1][k]);
    // k 是 2 ^ k <= (r - l + 1) 的最大值
    // dp[l][k] 负责 [l, l + (1 << k) - 1] 区间内的最值
    // dp[r - (1 << k) + 1][k] 负责 [r - (1 << k) + 1, r] 区间内的最值
    // 这两个区间覆盖了 [l, r] 区间，所有结果正确
}
```